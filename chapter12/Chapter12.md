# Chapter12

1. `new`在动态内存中为对象分配空间并返回一个指向该对象的指针；`delete`接受一个动态对象的指针，销毁该对象，并释放与之关联的内存
2. `shared_ptr`允许多个指针指向同一个对象；`unique_ptr`则“独占”所指向的对象；`weak_ptr`伴随类，一种弱引用，指向`shared_ptr`所管理的对象；定义在`<memory>`中
3. 通用操作

| 操作                                   | 备注                                                         |
| -------------------------------------- | ------------------------------------------------------------ |
| shared_ptr<T> sp<br />unique_ptr<T> up | 空智能指针，可以指向类型为T的对象                            |
| p                                      | 将p用作一个条件判断，若p指向一个对象，则为true               |
| *p                                     | 解引用p，获得它指向的对象                                    |
| p->mem                                 | 等价于(*p).mem                                               |
| p.get()                                | 返回p中保存的指针。要小心使用，若智能指针释放了其对象，返回的指针所指向的对象也就消失了 |
| swap(p, q)<br />p.swap(q)              | 交换p和q中的指针                                             |

4. `shared_ptr`独有操作

| 操作                  | 备注                                                         |
| --------------------- | ------------------------------------------------------------ |
| make_shared<T> (args) | 返回一个shared_ptr，指向一个动态分配的类型为T的对象。使用args初始化此对象 |
| shared_ptr<T> p(q)    | p是shared_ptr q的拷贝；此操作会递增q中的计数器。q中的指针必须能转换为T* |
| p = q                 | p和q都是shared_ptr，所保存的指针必须能相互转换。此操作会递减p的引用计数，递增q的引用计数；若p的引用计数变为0，则将其管理的原内存释放 |
| p.unique()            | 若p.use_count()为1，返回true；否则返回false                  |
| p.use_count()         | 返回与p共享对象的只能指针数量；可能很慢，主要用于调试        |

5. `make_shared`最安全的分配和使用动态内存方法，定义在`<memory>`中

```c++
shared_ptr<int> p3 = make_shared<int>(42);
shared_ptr<string> p4 = make_shared<string>(10, '9');
shared_ptr<int> p5 = make_shared<int>();
```

6. 当进行拷贝或赋值操作时，每个`shared_ptr`都会记录有多少个其他`shared_ptr`指向相同的对象

```c++
auto p = make_shared<int>(42);	//p指向的对象只有p一个引用者
auto q(p);	//p和q指向相同对象，此对象有两个引用者
```

`shared_ptr`有一个关联的计数器，成为**引用计数**，当计数为0时，会自动释放自己管理的对象

7. `shared_ptr`自动销毁所管理的对象时，会调用对象的析构函数，还会自动释放相关联的内存
8. 如果将`shared_ptr`存放在一个容器中，而后不再需要全部元素，而只使用其中一部分，要记得用`erase`删除不再需要的那些元素

9. 如果`new`不能分配所要求的内存空间，它会抛出一个类型为`bad_alloc`的异常，可以改变使用`new`的方式来阻止它抛出异常 ，`bad_alloc`和`nothrow`定义在`new`中

```c++
int *p1 = new int;	//如果分配失败，抛出std::bad_alloc
int *p2 = new (nothrow) int;	//分配失败，new 返回一个空指针
```

10. 管理动态内存常见三种错误

* 忘记`delete`内存
* 使用已经释放掉的对象
* 同一块内存释放两次

11. 坚持只使用智能指针，可以避免所有这些问题。对于一块内存，只有在没有任何智能指针指向它的情况下，智能指针才会自动释放它
12. `delete`之后，将指针赋予`nullptr`
13. `shared_ptr`和`new`结合使用，但必须使用直接初始化形式来初始化一个智能指针

```c++
shared_ptr<int> p1 = new int(1024);	//错误
shared_ptr<int> p2(new int(1024)); 	//正确，直接初始化
```

14. 定义和改变`shared_ptr`的其他方法

| 方法                                         | 备注                                                         |
| -------------------------------------------- | ------------------------------------------------------------ |
| shared_ptr<T> p(q)                           | p管理内置指针q所指向的对象；q必须指向new分配的内存，且能够转换为T*类型 |
| shared_ptr<T> p(u)                           | p从unique_ptr u那里接管了对象的所有权；将u置为空             |
| shared_ptr<T> p(q, d)                        | p接管了内置指针q所指向的对象的所有权。q必须能转换为T*类型。p将使用可调用对象d来代替delete |
| shared_ptr<T> p(p2, d)                       | p是shared_ptr p2的拷贝，唯一的区别是p将用可调用对象d来代替delete |
| p.reset()<br />p.reset(q)<br />p.reset(q, d) | 若p是唯一指向其对象的shared_ptr，reset会释放此对象。若传递了可选的参数内置指针q，会令p指向q，否则会将p置空。若还传递了参数d，将会调用d而不是delete来释放q |

15. 使用一个内置指针来访问一个智能指针所负责的对象是危险的，因为我们无法知道对象何时会被销毁
16. `get`用来将指针的访问权限传递给代码，你只有在确定代码不会`delete`指针的情况下，才能使用`get`.特别是，永远不要用`get`初始化另一个智能指针或者为另一个智能指针赋值
17. 通过`share_ptr`创建的对象，无法函数是正确处理结束还是发生异常退出，该对象都会被销毁
18. 那些分配了资源，而又没有定义析构函数来释放这些资源的类，可能会遇到与使用动态内存相同的错误；如果在资源分配和释放之间发生了异常，程序也会发生资源泄露；默认情况下，`shared_ptr`假定它们指向的是动态内存，因此当一个`share_ptr`被销毁时，它默认地对它管理的指针进行`delete`操作。为了用`shared_ptr`来管理一个`connection`，我们必须首先定义一个函数来代替`delete`。这个**删除器**函数必须能够完成对`share_ptr`中保存的指针进行释放的操作

```c++
void end_connection(connection *p){disconnect(*p);}
void f(destination &d){
    connection c = connect(&d);
    shared_ptr<connection> p(&c, end_connection);
    //使用连接
    //当f退出时(即使是由于异常而退出)，connection会被正确关闭
}
```

19. 使用指针陷阱基本规范

* 不使用相同的内置指针值初始化(或reset)多个智能指针
* 不`delete`、`get()`返回的指针
* 不使用`get()`初始化或`reset`另一个智能指针
* 如果你使用`get()`返回的指针，记住当最后一个对应的智能指针销毁后，你的指针就变为无效了
* 如果你使用的智能指针管理的资源不是new分配的内存，进驻传递给它一个删除器

20. `unique_ptr`“拥有”它所指向的对象；与`shared_ptr`不同，某个时刻只能有一个`unique_ptr`指向一个给定对象。当`unique_ptr`被销毁时，它所指向的对象也被销毁
21. 初始化`unique_ptr`必须采用直接初始化形式，不支持普通拷贝或赋值操作
22. `unique_ptr`操作

| 操作                                            | 备注                                                         |
| ----------------------------------------------- | ------------------------------------------------------------ |
| unique_ptr<T> u1<br />unique_ptr<T, D> u2       | 空unique_ptr,可以指向类型为T的对象。u1会使用delete来释放它的指针；u2会使用一个类型为D的可调用对象来释放它的指针 |
| unique_ptr<T, D> u(d)                           | 空unique_ptr，指向类型为T的对象，用类型为D的对象d代替delete  |
| u = nullptr                                     | 释放u指向的对象，将u置为空                                   |
| u.release()                                     | u放弃对象指针的控制权，返回指针，并将u置为空                 |
| u.reset()<br />u.reset(q)<br />u.reset(nullptr) | 释放u指向的对象；如果提供了内置指针q，令u指向这个对象；否则将u置为空 |

23. `weak_ptr`是一种不控制所指向对象生存期的智能指针，它指向由一个`shared_ptr`管理的对象。将一个`weak_ptr`绑定到一个`shared_ptr`不会改变`shared_ptr`的引用计数，一旦最后一个指向对象的`shared_ptr`被销毁，对象就会被释放
24. `weak_ptr`操作

| 操作              | 备注                                                         |
| ----------------- | ------------------------------------------------------------ |
| weak_ptr<T> w     | 空weak_ptr可以指向类型为T的对象                              |
| weak_ptr<T> w(sp) | 与shared_ptr sp指向相同对象的weak_ptr。T必须能转换为sp指向的类型 |
| w = p             | p可以是一个shared_ptr或一个weak_ptr。赋值后w与p共享对象      |
| w.reset()         | 将w置为空                                                    |
| w.use_count       | 与w共享对象的shared_ptr的数量                                |
| w.expired()       | 若w.use_count为0，返回true，否则返回false                    |
| w.lock()          | 如果expired为true，返回一个空shared_ptr；否则返回一个指向w的对象的shared_ptr |

25. 动态数组

```c++
int *pia = new int[10];
delete []pia;
```

26. 如果在`delete`一个数组指针时忘记了方括号，或者在`delete`一个单一对象的指针时使用了方括号，编译器可能不会给出警告，程序可能在执行过程中在没有任何警告的情况下行为异常

27. `unique_ptr`指向动态数组

| 操作                 | 备注                                                         |
| -------------------- | ------------------------------------------------------------ |
|                      | 指向数组的unique_ptr不支持成员访问运算符(点或箭头运算符)<br />其他unique_ptr操作不便 |
| unique_ptr<T[]> u    | u可以指向一个动态分配的数组，数组元素类型为T                 |
| unique_ptr<T[]> u(p) | u指向内置指针p锁住西乡的动态分配的内存。p必须能转换为类型T*  |
| u[i]                 | 返回u拥有的数组中位置i处的对象，u必须指向一个数组            |

28. `new`操作表现在它将内存分配和对象构造组合在一起；`delete`操作将对象析构和内存释放组合在一起
29. `allocator`类`<memory>`

| 操作                 | 备注                                                         |
| -------------------- | ------------------------------------------------------------ |
| allocator<T> a       | 定义一个名为a的allocator对象，它可以为类型为T的对象分配内存  |
| a.allocate(n)        | 分配一段原始的、未构造的内存，保存n个类型为T的对象           |
| a.deallocate(p, n)   | 释放从T*指针p中地址开始的内存，这块内存保存了n个类型为T的对象；p必须是一个先前由allocate返回的指针，且n必须是p创建时所要求的大小。在调用deallocate之前，用户必须对每个在这块内存中创建的对象调用destroya |
| a.construct(p, args) | p必须是一个类型为T*的指针，指向一块原始内存；arg被传递给类型为T的构造函数，用来在p指向的内存中构造一个对象 |
| a.destroy(p)         | p为T*类型的指针，此算法对p指向的对象执行析构函数             |

30. 为了使用`allocate`返回的内存，必须用`construct`构造对象。使用未构造的内存，其行为是未定义的
31. 只能对真正构造的元素进行`destroy`操作

32. `allocator`算法

| 操作                                                       | 备注                                                         |
| ---------------------------------------------------------- | ------------------------------------------------------------ |
| 这些函数在给定目的位置创建元素，而不是由系统分配内存给它们 |                                                              |
| uninitialized_copy(b, e, b2)                               | 从迭代器b和e指出的输入范围中拷贝元素到迭代器b2指定的未构造的原始内存中。b2指向的内存必须足够大，能容纳输入序列中的元素的拷贝 |
| uninitialized_copy_b(b, n, b2)                             | 从迭代器b指向的元素开始，拷贝n个元素到b2开始的内存中         |
| uninitialized_fill(b, e, t)                                | 在迭代器b和e指定的原始内存范围中创建对象，对象的值均为t的拷贝 |
| uninitialized_fill_n(b, n, t)                              | 从迭代器b指向的内存地址开始创建n个对象。b必须指向足够大的未构造的原始内存，能够容纳给定数量的对象 |