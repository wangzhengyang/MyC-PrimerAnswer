# Chapter12

1. `new`在动态内存中为对象分配空间并返回一个指向该对象的指针；`delete`接受一个动态对象的指针，销毁该对象，并释放与之关联的内存
2. `shared_ptr`允许多个指针指向同一个对象；`unique_ptr`则“独占”所指向的对象；`weak_ptr`伴随类，一种弱引用，指向`shared_ptr`所管理的对象；定义在`<memory>`中
3. 通用操作

| 操作                                   | 备注                                                         |
| -------------------------------------- | ------------------------------------------------------------ |
| shared_ptr<T> sp<br />unique_ptr<T> up | 空智能指针，可以指向类型为T的对象                            |
| p                                      | 将p用作一个条件判断，若p指向一个对象，则为true               |
| *p                                     | 解引用p，获得它指向的对象                                    |
| p->mem                                 | 等价于(*p).mem                                               |
| p.get()                                | 返回p中保存的指针。要小心使用，若智能指针释放了其对象，返回的指针所指向的对象也就消失了 |
| swap(p, q)<br />p.swap(q)              | 交换p和q中的指针                                             |

4. `shared_ptr`独有操作

| 操作                  | 备注                                                         |
| --------------------- | ------------------------------------------------------------ |
| make_shared<T> (args) | 返回一个shared_ptr，指向一个动态分配的类型为T的对象。使用args初始化此对象 |
| shared_ptr<T> p(q)    | p是shared_ptr q的拷贝；此操作会递增q中的计数器。q中的指针必须能转换为T* |
| p = q                 | p和q都是shared_ptr，所保存的指针必须能相互转换。此操作会递减p的引用计数，递增q的引用计数；若p的引用计数变为0，则将其管理的原内存释放 |
| p.unique()            | 若p.use_count()为1，返回true；否则返回false                  |
| p.use_count()         | 返回与p共享对象的只能指针数量；可能很慢，主要用于调试        |

5. `make_shared`最安全的分配和使用动态内存方法，定义在`<memory>`中

```c++
shared_ptr<int> p3 = make_shared<int>(42);
shared_ptr<string> p4 = make_shared<string>(10, '9');
shared_ptr<int> p5 = make_shared<int>();
```

6. 当进行拷贝或赋值操作时，每个`shared_ptr`都会记录有多少个其他`shared_ptr`指向相同的对象

```c++
auto p = make_shared<int>(42);	//p指向的对象只有p一个引用者
auto q(p);	//p和q指向相同对象，此对象有两个引用者
```

`shared_ptr`有一个关联的计数器，成为**引用计数**，当计数为0时，会自动释放自己管理的对象

7. `shared_ptr`自动销毁所管理的对象时，会调用对象的析构函数，还会自动释放相关联的内存
8. 如果将`shared_ptr`存放在一个容器中，而后不再需要全部元素，而只使用其中一部分，要记得用`erase`删除不再需要的那些元素

9. 如果`new`不能分配所要求的内存空间，它会抛出一个类型为`bad_alloc`的异常，可以改变使用`new`的方式来阻止它抛出异常 ，`bad_alloc`和`nothrow`定义在`new`中

```c++
int *p1 = new int;	//如果分配失败，抛出std::bad_alloc
int *p2 = new (nothrow) int;	//分配失败，new 返回一个空指针
```

10. 管理动态内存常见三种错误

* 忘记`delete`内存
* 使用已经释放掉的对象
* 同一块内存释放两次

11. 坚持只使用智能指针，可以避免所有这些问题。对于一块内存，只有在没有任何智能指针指向它的情况下，智能指针才会自动释放它
12. `delete`之后，将指针赋予`nullptr`
13. `shared_ptr`和`new`结合使用，但必须使用直接初始化形式来初始化一个智能指针

```c++
shared_ptr<int> p1 = new int(1024);	//错误
shared_ptr<int> p2(new int(1024)); 	//正确，直接初始化
```



