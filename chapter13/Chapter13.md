# Chapter13

1. 拷贝构造函数

```c++
class Foo{
public:
    Foo();				//默认构造函数
    Foo(const Foo&);	//拷贝构造函数
    //...
};
```

2. 拷贝构造函数发生情况

* 将一个对象作为实参传递给一个非引用类型的形参
* 从一个返回类型为非引用类型的函数返回一个对象
* 用花括号列表初始化一个数组中的元素或一个聚合类中的成员

3. 使用`explicit`的构造函数必须按形式传递

4. 重载赋值运算符，其通常应该返回一个指向其左侧运算对象的引用

```c++
class Foo{
public:
    Foo& operator=(const Foo&); //赋值运算符
    //...
};
```

5. 隐式销毁一个内置指针类型的成员不会`delete`它所指向的对象
6. 析构函数调用情况

* 变量在离开其作用域时被销毁
* 当一个对象被销毁时，其成员被销毁
* 容器(无论标准库容器还是数组)被销毁时，其元素被销毁
* 对于动态分配的对象，当对指向它的指针应用`delete`运算符时被销毁
* 对于临时对象，当创建它的完整表达式结束时被销毁

7. 当指向一个对象的引用或指针离开作用域时，析构函数不会执行
8. 如果一个类需要自定义析构函数，几乎可以肯定它也需要自定义拷贝赋值运算符合拷贝构造析构函数
9. 可以将拷贝控制成员定义为`=default`来显示地要求编译器生成合成默认版本
10. 在类内用`=default`修饰成员的声明时，合成的函数将隐式地声明为内联，如果不希望合成的成员是内联函数，应该只对成员的类外定义使用`=default`
11. 使用`=delete`阻止拷贝，不让程序使用拷贝构造函数以及重载赋值运算符
12. 如果定义析构函数也是删除的，我们不能定义这种类型的变量或成员，但可以动态分配这种类型的对象，不能释放这些对象
13. 本质上，当不可能拷贝、赋值或销毁类的成员时，类的合成拷贝控制成员就被定义为删除的
14. 可以将拷贝构造函数和拷贝赋值运算符声明为`private`，为了阻止友元和成员函数进行拷贝

15. 编写赋值运算符时，有两点需要注意：

* 如果将一个对象赋予它自身，赋值运算符必须能正确工作
* 大多数赋值运算符组合析构函数和拷贝构造函数的工作

16. 定义拷贝操作可以让类的行为看起来像一个值或者像一个指针；类的行为像一个值，意味着它有自己的状态，副本和原对象是完全独立的，改变副本不会对原对象有任何影响；行为像指针的类则共享状态，副本和原对象使用相同的底层数据，改变副本也会改变原对象
17. 对于一个赋值运算符来说，正确工作是非常重要的，即使是将一个对象赋予它自身，也要能正确工作。好的方法是在销毁左侧运算对象资源之前拷贝右侧运算对象
18. 行为像指针的类，只有当最后一个指向动态分配的对象的类销毁时才可以释放动态分配的对象，通过**引用计数**来实现
19. **引用计数**工作方式

* 除了初始化对象外，每个构造函数(拷贝构造函数除外)还要创建一个引用计数，用来记录有多少个对象与正在创建的对象共享状态。当我们创建一个对象时，只有一个对象共享状态，因此将计数器初始化为1
* 拷贝构造函数不分配新的计数器，而是拷贝给定对象的数据成员，包括计数器。拷贝构造函数递增共享的计数器，指出给定对象的状态又被一个新用户所共享
* 析构函数递减计数器，指出共享状态的用户少一个。如果计数器变为0，则析构函数释放状态
* 拷贝赋值运算符递增右侧运算符对象的计数器，递减左侧运算符对象的计数器。如果左侧运算符对象的计数器变为0，意味着它的共享状态没有用户，拷贝赋值运算符就必须销毁状态

20. 与拷贝控制成员不同，`swap`并不是必要的。但是，对于分配了资源的类，定义`swap`可能是一种很重要的优化手段
21. 使用拷贝和交换的赋值运算符自动就是异常安全的，且能正确处理自赋值