# Chapter14

1. 当一个重载的运算符是成员函数时，`this`绑定到左侧运算对象；成员运算符函数的(显式)参数数量比运算对象的数量少一个
2. 对于二元运算符来说，左侧运算对象传递给第一个参数，而右侧运算对象传递给第二个参数
3. 运算符

| 运算符                                                       | 备注               |
| ------------------------------------------------------------ | ------------------ |
|                                                              | 可以被重载的运算符 |
| + - * / % ^ & \| ~ ! , = < > <= >= ++ -- << >> ==  != && \|\| += -= /= %= ^= &= \|= *= <<= >>= [] () -> ->* new new[] delete delete[] |                    |
|                                                              | 不能被重载的运算符 |
| :: .* . ?:                                                   |                    |

3. 通常情况下，不应该重载逗号、取地址、逻辑与和逻辑或运算符
4. 运算符定义为成员函数还是普通的非成员函数抉择

* 赋值(=)、下标([])、调用(())和成员访问箭头(->)运算符必须是成员
* 复合赋值运算符一般来说应该是成员，但并非必须，这一点与赋值运算符略有不同
* 改变对象状态的运算符或者与给定类型密切相关的运算符，如递增、递减和解引用运算符，通常应该是成员
* 具有对称性的运算符可能转换任意一端的运算对象，例如算术、相等性、关系和位预算符等，因此它们通常应该是普通的非成员函数

5. 重载输出运算符`<<`

```c++
ostream &operator<<(ostream &os, const Sales_data &item);
```

6. 通常输出运算符应该主要负责打印对象的内容而非控制格式，输出运算符不应该打印换行符
7. 重载输入运算符`>>`

```c++
ostream &operator>>(istream &is, Sales_data &item);
```

8. 输入运算符必须处理输入可能失败的情况，而输出运算符不需要

9. 执行输入运算符时可能发生以下错误

* 当流含有错误类型的数据时读取操作可能失败
* 当读取操作到达文件末尾或者遇到输入流的其他错误时也会失败

* 可以在读取完所有数据后进行一次性检查

10. 当读取操作发生错误时，输入运算符应该负责从错误中恢复
11. 如果类同时定义了算术运算符和相关的复合赋值运算符，则通常情况下应该使用复合赋值来实现算术运算符
12. 相等运算符设计准则

* 如果一个类含有判断两个对象是否相等的操作，则它显然应该把函数定义成`operator==`而非一个普通的命名函数
* 如果类定义了`operator==`，则该运算符应该能判断一组给定的对象中是否含有重复数据
* 通常情况下，相等运算符应该具有传递性，如果a==b和b==c都为真，则a==c也应该为真
* 如果类定义了`operator==`，则这个类也应该定义`operator!=`；对于用户来说，当他们能使用`==`时肯定也希望使用`!=`
* 相等运算符和不相等运算符中的一个应该把工作委托给另外一个，这意味着其中一个运算符应该负责实际比较对象的工作，而另一个运算符则只是调用那个真正工作的运算符

13. 如果某个类在逻辑上有相等性的含义，则该类应该定义`operator==`，这样做可以使得用户更容易使用标准库算符来处理这个类
14. 如果存在唯一一种逻辑可靠的`<`定义，则应该考虑为这个类定义`<`运算符。如果类同时还包含`==`，则当且仅当`<`的定义和`==`产生的结果一致时才定义`<`运算符
15. 可以重载赋值运算符，不论形参的类型是什么，赋值运算符都必须定义为成员函数
16. 赋值运算符必须定义成类的成员，复合赋值运算符通常情况下也应该这样做。这两类运算符都应该返回左侧运算对象的引用
17. 下标运算符必须是成员函数
18. 如果一个类包含下标运算符，则它通常会定义两个版本：一个返回普通引用，另一个是类的常量成员并且返回常量引用
19. 定义递增和递减运算符的类应该同时定义前置版本和后置版本，这些运算符通常应该被定义成类的成员
20. 为了与内置版本保持一致，前置运算符应该返回递增或递减后对象的引用
21. 后置版本接受一个额外的(不被使用)`int`类型形参来标识，为了与内置版本保持一致，后置运算符应该返回对象的原值(递增或递减之前的值)，返回的形式是一个值而非引用
22. 箭头运算符必须是类的成员；解引用运算符通常也是类的成员，尽管并非必须如此

```c++
class StrBlobPtr{
public:
    std::string& operator*()const{
        auto p = check(curr, "dereference past end");
        return (*p)[curr];
    }
    std::string* operator->()const{
        return &this->operator*();
    }
};
```

23. 重载的箭头运算符必须返回类的指针或者自定义了箭头运算符的某个类的对象
24. 函数调用运算符必须是成员函数；一个类可以定义多个不同版本的调用运算符，相互之间应该在参数数量或类型上有所区别
25. 标准库函数对象`<functional>`

| 函数对象            | 备注 |
| ------------------- | ---- |
|                     | 算术 |
| plus<Type>          |      |
| minus<Type>         |      |
| multiplies<Type>    |      |
| divides<Type>       |      |
| modules<Type>       |      |
| negate<Type>        |      |
|                     | 关系 |
| equal_to<Type>      |      |
| not_equal_to<Type>  |      |
| greater<Type>       |      |
| greater_equal<Type> |      |
| ·less<Type>         |      |
| less_equal<Type>    |      |
|                     | 逻辑 |
| logical_and<Type>   |      |
| logical_or<Type>    |      |
| logical_not<Type>   |      |

26. 标准库`function` `<functional>`

| 操作                                                         | 备注                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| function<T> f;                                               | f是一个用来存储可调用对象的空function，这些可调用对象的调用形式应该与函数类型T相同(即T是retType(args)) |
| function<T> f(nullptr);                                      | 显示地构造一个空function                                     |
| function<T> f(obj);                                          | 在f中存储可调用对象obj的副本                                 |
| f                                                            | 将f作为条件；当f含有一个可调用对象时为真；否则为假           |
| f(args)                                                      | 调用f中的对象， 参数是args                                   |
|                                                              | 定义为function<T>的成员的类型                                |
| result_type                                                  | 该function类型的可调用对象返回的类型                         |
| argument_type<br />first_argument_type<br />second_argument_type | 当T有一个或两个实参时定义的类型。如果T只有一个实参，则argument_type是该类型的同义词；如果T有两个实参，则first_argument_type和second_argument_type分别代表两个实参的类型 |

27. 显示的类型转换运算符

```c++
class SmallInt{
public:
    explicit operator int() const {return val;}
};
```

28. 通常情况下，不要为类定义相同的类型转换，也不要在类中定义两个及两个以上转换源或转换目标是算数类型的转换