# Chapter15

1. **面向对象程序设计**的核心思想是数据抽象、继承和动态绑定；使用数据抽象，将类的接口与实现分离；使用继承，可以定义相似的类型并对其相似关系建模；使用动态绑定，可以在一定程度上忽略相似类型的区别，而以统一方式使用它们的对象
2. 基类通过虚函数让派生类各自定义适合自身版本的信息
3. 派生类通过`virtual`对虚函数进行声明，通过`override`显式地注明改写基类虚函数
4. 在C++语言中，使用基类的引用(或指针)调用一个虚函数时将发生动态绑定
5. 基类通常都应该定义一个虚析构函数，即使该函数不执行任何实际操作也是如此
6. 在派生类对象中含有与其基类对应的组成部分，这一事实是继承的关键所在
7. 每个类控制它自己的成员初始化过程；首先初始化基类的部分，然后按照声明的顺序依次初始化派生类的成员
8. 每个类负责定义各自的接口，要想与类的对象交互必须使用该类的接口，即使这个对象时派生类的基类部分也是如此，派生类应该遵循基类的接口，并且通过调用基类的构造函数来初始化那些从基类中继承而来的成员
9. 派生类的声明只包含类名但是不包含它的派生列表
10. 如果某个类用作基类，则该类必须已经定义而非仅仅声明
11. 通过在类名后面添加`final`从而防止继承发生
12. 和内置指针一样，智能指针类也支持派生类向基类的类型转换，我们可以将一个派生类对象的指针存储在一个基类的智能指针内
13. 基类的指针或引用的静态类型可能与其动态类型不一致
14. 当我们用一个派生类对象为一个基类对象初始化或赋值时，只有该派生类对象中的基类部分会被拷贝、移动或赋值，它的派生类部分将被忽略掉
15. 存在继承关系的类型之间转换规则

* 从派生类向基类的类型转换只对指针或引用类型有效
* 基类向派生类不存在隐式类型转换
* 和任何其他成员一样，派生类向基类的类型转换也可能会由于访问受限而变得不可行

尽管自动类型转换只对指针或引用类型有效，但是继承体系中的大多数类仍然(显式或隐式地)定义了拷贝控制成员。因此，通常能够将一个派生类对象拷贝、移动或赋值给一个基类对象。不过注意的是，这种操作只处理派生类对象的基类部分

16. 动态绑定只有当通过指针或者引用调用虚函数时才会发生；当且仅当对通过指针或引用调用虚函数时，才会在运行时解析该调用，也只有在这种情况下对象的动态类型才有可能与静态类型不同
17. 基类中的虚函数在派生类中隐含地也是一个虚函数。当派生类覆盖了某个虚函数时，该函数在基类中的形参必须与派生类中的形参严格匹配
18. 通过`override`说明派生类中的虚函数，从而让编译器能够发现错误
19. 通过`final`定义函数，则之后任何尝试覆盖该函数的操作都将引发错误
20. 如果虚函数使用默认实参，则基类和派生类中定义的默认实参最好一致
21. 通常情况下，只有成员函数(或友元)中的代码才需要使用作用域运算符来回避虚函数的机制；如果一个派生类虚函数需要调用它的基类版本，但是没有使用作用域运算符，则在运行时该调用将被解析为对派生类版本自身的调用，从而导致无限递归

```c++
double  undiscounted = baseP->Quote::net_price(42);
```

22. 使用`=0`定义纯虚函数，其中`=0`只能出现在类内部的虚函数声明语句处
23. 含有(或者未经覆盖直接继承)纯虚函数的类是**抽象基类**，抽象基类负责定义接口，而后续的其他类可以覆盖该接口
24. 不能创建抽象基类的对象
25. 重构负责重新设计类的体系以便将操作和/或数据从一个类移动到另一个类中；对于面向对象的应用程序来说，重构是一种很普遍的现象
26. 不能继承友元关系；每个类负责控制各自成员的访问权限
27. 派生类使用`using`声明来提供可访问的名字
28. 一个私有派生的类最好显示地将`private`声明出来，而不要仅仅依赖于默认的设置；显示声明的好处是可以令私有继承关系清晰明了，不至于产生误会
29. 派生类的成员将隐藏同名的基类成员；除了覆盖继承而来的虚函数之外，派生类最好不要重用其他定义在基类中名字
30. 虚析构函数确保执行正确的析构函数版本，如果基类的析构函数不是虚函数，则`delete`一个指向派生类对象的基类指针将产生未定义的行为
31. 当派生类定义了拷贝或移动操作时，该操作负责拷贝或移动包括基类部分成员在内的整个对象
32. 默认情况下，基类默认构造函数初始化派生类对象的基类部分，如果想拷贝(或移动)基类部分，则必须在派生类的构造函数初始化列表中显式地使用基类的拷贝(或移动)构造函数
33. 派生类析构函数只负责销毁由派生类自己分配的资源，在对象销毁过程中，派生类析构函数首先执行，然后是基类的析构函数
34. 如果构造函数或析构函数调用某个虚函数，则应该执行与构造函数或析构函数所属类型相对应的虚函数版本
35. 当派生类对象被赋值给基类对象时，其中派生类部分将被"切掉"，因此容器和存在继承关系的类型无法兼容
36. 在容器中放置(智能)指针而非对象

```c++
vector<shared_ptr<Quote>> basket;
basket.push_back(make_shared<Quote>("0-201-82470-1", 50));
```



