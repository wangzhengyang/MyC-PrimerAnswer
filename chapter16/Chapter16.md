# Chapter16

1. 函数模板定义中，模板参数列表不能为空

```c++
tempalte<typename T>
int compare(const T &v1, const T &v2)
{
    if (v1 < v2) return -1;
    if (v2 < v1) return 1;
    return 0;
}
```

2. 非类型参数模板

```c++
template<unsigned N, unsigned M>
int compare(const char (&p1)[N], const char (&p2)[M])
{
    return strcmp(p1, p2);
}
```

3. 非类型模板参数的模板实参必须是常量表达式

4. 编写泛型代码的重要原则

* 模板中的函数参数是`const`的引用(保证函数可以用于不能拷贝的类型)
* 函数体中的条件判断仅使用`<`比较运算符

5. 模板程序应该尽量减少对实参类型的要求
6. 函数模板和类模板成员函数的定义通常放在头文件中
7. 保证传递给模板的实参支持模板所要求的操作，以及这些操作在模板中能正确工作，是调用者的责任
8. 一个类模板的每个实例都形成一个独立的类。类与类之间没有关联，也不会对其他类的成员有特殊的访问权限
9. 默认情况下，对于一个实例化的类模板，其成员只有在使用时才被实例化
10. 在一个类模板的作用域内，可以直接使用模板名而不必指定模板实参
11. 一个特定文件所需要的所有模板的声明通常一起放置在文件开始位置，出现于任何使用这些模板的代码之前
12. 当希望通知编译器一个名字表示类型时，必须使用关键字`typename`，而不能使用`class`
13. **默认模板实参**为函数参数提供默认实参
14. 对每个实例化声明，在程序中某个位置必须有其显式的实例化定义
15. 在一个类模板的实例化定义中，所有类型必须能用于模板的所有成员函数
16. 将实参传递给带模板类型的函数形参时，能够自动应用的类型转换只有`const`转换及数组或函数到指针的转换
17. 如果函数参数类型不是模板参数，则对实参进行正常的类型转换
18. 当参数是一个函数模板实例的地址时，程序上下文必须满足：对每个模板参数，能唯一确定其类型或值
19. 引用折叠只能应用于间接创建的引用的引用，如类型别名或模板参数
20. 如果一个函数参数是指向模板参数类型的右值引用(如`T&&`)，则可以传递给它任意类型的实参。如果将一个左值传递给这样的参数，则函数参数被实例化为一个普通的左值引用(`T&`)
21. 如果一个函数参数是指向模板类型参数的右值引用(如`T&&`)，它对应的实参的`const`属性和左值/右值属性将得到保持
22. 当用于一个指向模板参数类型的右值引用函数参数(`T&&`)时，`forward`会保持实参类型的所有细节
23. 与`std::move`相同，对`std::forward`不使用`using`声明是一个好主意

