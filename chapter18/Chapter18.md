# Chapter18

1. 执行一个`throw`时，跟在`throw`后面的语句将不再被执行，程序的控制权从`throw`转移到与之匹配的`catch`模块，所以`throw`语句的用法类似于`return`，将控制权从一处转移到另一处会导致：

* 沿着调用链的函数可能会提早退出
* 一旦程序开始执行异常处理代码，则沿着调用链穿件的对象将被销毁

2. 当抛出一个异常后，程序暂停当前函数的执行过程并立即开始寻找与异常匹配的`catch`子句
3. 一个异常如果没有被捕获，则它将终止当前的程序；程序调用标准库函数`terminate`
4. 在栈展开的过程中，运行类类型的局部对象的析构函数；因为这些西沟函数是自动执行的，所以它们不应该抛出异常；一旦在栈展开的过程中析构函数抛出了异常，并且析构函数自身没能捕获到该异常，则程序将被终止
5. 抛出指针要求在任何对应的处理代码存在的地方，指针所指的对象都必须存在
6. 通常情况下，如果`catch`接受的异常与某个继承体系有关，则最好将该`catch`的参数定义成引用类型
7. 如果在多个`catch`语句的类型之间存在着继承关系，则应该把继承链最底端的类放在前面，而将继承链最顶端的类放在后面
8. 使用`catch(...)`一次性捕获所有异常
9. 如果`catch(...)`与其他几个`catch`语句一起出现，则`catch(...)`必须在最后的位置；出现在捕获所有异常语句后面的`catch`语句将永远不会被匹配
10. 处理构造函数初始值异常的唯一方法是将构造函数写成函数`try`语句块

```c++
template <typename T>
Blob<T>::Blob(std::initializer_list<T> il) try:
	data(std::make_shared<std::vector<T> >(il)){ 
        /*空函数体*/
    }catch(const std::bad_alloc &e){handle_out_of_memory(e);}
```

11. `noexcept`指定某个函数不会抛出异常
12. 通常情况下，编译器不能也不必在编译时验证异常说明，使用`noexcept`的两种情况

* 我们确认函数不会抛出异常
* 我们根本不知道该如何处理异常

13. `noexcept(true)`函数不会抛出异常；`noexcept(false)`函数可能抛出异常
14. `noexcept`有两层含义：当跟在函数参数列表后面时它是异常说明符；而当作为`noexcept`异常说明的`bool`实参出现时，它是一个运算符
15. 异常类型

| 异常             | 备注                |
| ---------------- | ------------------- |
| exception        | 基类                |
| bad_cast         | 继承自exception     |
| bad_alloc        | 继承自exception     |
| runtime_error    | 继承自exception     |
| logic_error      | 继承自exception     |
| overflow_error   | 继承自runtime_error |
| underflow_error  | 继承自runtime_error |
| range_error      | 继承自runtime_error |
| domain_error     | 继承自logic_error   |
| invalid_argument | 继承自logic_error   |
| out_of_range     | 继承自logic_error   |
| length_error     | 继承自logic_error   |

16. 类型`exception`仅仅定义了拷贝构造函数、拷贝赋值运算符、一个虚析构函数和一个名为`what`的虚成员；其中`what`函数返回一个`const char*`，该指针指向一个以`null`结尾的字符数组，并且确保不会抛出任何异常
17. 类`exception`、`bad_cast`和`bad_alloc`定义了默认构造函数；类`runtime_error`和`logic_error`没有默认构造函数，但是有一个可以接受C风格字符串或者标准库`string`类型实参的构造函数，这些实参负责提供关于错误的更多信息；在这些类中，`what`负责返回用于初始化异常对象的信息；因为`what`是虚函数，所以当我们捕获基类的引用时，对`what`函数的调用将执行与异常对象动态类型对应的版本
18. 命名空间作用域后面无须分号
19. 定义多个类型不相关的命名空间应该使用单独的文件分别表示每个类型(或关联类型构成的集合)
20. 和其他命名空间不同，未命名的命名空间仅在特定的文件内部有效，其作用范围不会横跨多个不同的文件
21. 一个命名空间可以有好几个同义词或别名，所有别名都与命名空间原来的名字等价
22. 如果我们提供了一个队`std`等命名空间的`using`指示而未做任何特殊控制的话，将重新引入由于使用了多个库而造成的名字冲突问题
23. 可以从函数的限定名推断出查找名字时检查作用域的次序，限定名以相反次序指出被查找的作用域
24. 当一个类拥有多个基类时，有可能出现派生类从两个或更多基类中继承了同名成员的情况；此时，不加前缀限定符直接使用该名字将引发二义性
25. 虚派生只影响从指定了虚基类的派生类中进一步派生出的类，它不会影响派生类本身
26. 虚基类总是先于非虚基类构造，与它们在继承体系中的次序和位置无关

