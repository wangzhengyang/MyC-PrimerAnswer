# Chapter2

1. `wchar_t`宽字符16位
2. 类型转换

* 一个非布尔类型的算术值赋给布尔类型，初始值为0则结果为false，否则结果为true
* 一个布尔值赋给非布尔类型时，初始值为false则结果为0，初始值为true则结果为1
* 一个浮点数赋给整数类型时，进行近似处理。结果值将仅保留浮点数中小数点之前的部分
* 一个整数值赋给浮点类型时，小数部分记为0，如果该整数所占的空间超过了浮点类型的容量，精度可能有损失
* 赋给无符号类型一个超出它表示范围的值时，结果是初始值对无符号类型表示数值总数取模后的余数
* 赋给带符号类型一个超出它表示范围的值时，结果时**未定义的**。程序可能继续工作、可能崩溃、也可能产生垃圾数据

3. 类型选择

* 当明确知晓数值不可能为负时，选用无符号类型
* 使用int执行整数运算。如果你的数值超过了int的表示范围，选用long long
* 在算术表达式中不要使用char或bool，只有在存放字符或布尔值时才使用它们
* 执行浮点数运算选用double

4. 有符号数与无符号数进行计算时，有符号数会自动转换为无符号数
5. 初始化不是赋值，初始化的含义是创建变量时赋予其一个初始值，而赋值的含义是把对象的当前值擦除，而以一个新值来替代
6. 初始化，使用**列表初始化**如果初始值存在丢失信息的风险，则编译器会报错

```c++
int a = 0;
int a = {0};
int a{0};
int a(0);
```

7. 变量能且只能被定义一次，但是可以被多次声明
8. 一般来说，在对象第一次被使用的地方附近定义它是一种好的选择，因为这样做有助于更容易地找到变量的定义，更重要的是，当变量的定义与它第一次被使用的地方很近时，我们也会赋给它一个比较合理的初始值
9. **引用不会拷贝变量值**，并非对象，它只是为一个已经存在的对象所起的另外一个名字，所以**引用必须初始化**，**引用只能绑定在对象上，而不能与字面值或某个表达式的计算结果绑定在一起**，**引用的类型必须与绑定的对象严格匹配**
10. 指针是一个对象，允许对指针赋值和拷贝，而且在指针的生命周期内它可以先后指向几个不同的对象，其次指针无须在定义时赋初值
11. `nullptr`空指针，它可以被转换成任意其他的指针类型
12. `void*`特殊的指针类型，可用于存放任意对象的地址，仅仅代表内存空间，没办法访问内存空间中所存的对象
13. `const`对象仅在文件内有效，如果想在多个文件之间共享`const`对象，必须在变量的定义之前添加`extern`关键字

```c++
//file.cpp
extern const int bufSize = fcn();
//file.h
extern const int bufSize;
```

14. `const`引用不能被用作修改它所绑定的对象，非常量引用无法指向常量对象，但是常量引用可以指向常量对象，也可以指向非常量对象，只是指向非常量对象时，无法通过引用修改非常量的值

```c++
const int a = 10;
int &a1 = a; //错误
const int &a2 = a; //正确

int b = 10;
const int &b1 = b; //正确，但是通过b1无法修改b的值
int &b2 = b; //正确，可以通过b2修改b的值
```

15. `const`指针，常量指针必须初始化，而且一旦初始化，它的值(存放在指针中的那个地址)就不能改变

```c++
int errNumb = 0;
int *const curErr = &errNumb;
const double pi = 3.14159;
const double* const pip = &pi;
```

16. `constexpr`变量，如果你认定变量是一个常量表达式，那就把它声明成`constexpr`类型，`constexpr`把它所定义的对象置为顶层`const`

```c++
const int* p = nullptr; //p是一个指向整型常量的指针
constexpr int *q = nullptr; //q是一个指向整型的常量指针
```

17. `typedef`以及`using`类型别名

```c++
typedef double do;
using do = double;
```

18. `auto`类型说明符，让编译器通过初始值来推算变量的类型，必须有初始值
19. `decltype`类型指示符，它的作用是选择并返回操作数的数据类型，从变量或表达式推断得到类型
20. `decltype((variable))`(注意是双层括号)的结果永远是引用，而`decltype(variable)`结果只有当`variable`本身就是一个引用时才是引用
21. 自定义数据类型中，可以为数据成员提供一个**类内初始值**，创建对象时，类内初始值将用于初始化数据成员，没有初始值的成员将被默认初始化