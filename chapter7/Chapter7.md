# Chapter7

1. 类的基本思想是**数据抽象**和**封装**，数据抽象是一种依赖于**接口**和**实现**分离的编程(以及设计)技术
2. 类要想实现数据抽象和封装，需要首先定义一个**抽象数据类型**
3. 定义在类内部的函数是隐式的`inline`函数
4. 类成员函数通过一个名为`this`的额外隐式参数来访问调用它的那个对象
5. 类成员函数中紧随参数列表之后的`const`关键字是用来修改隐式`this`指针的类型，默认情况下，`this`的类型是指向类类型非常量版本的常量指针，通过添加`const`让类成员函数在函数体实现过程中无法修改类成员变量
6. 通过`return *this`来获取执行该函数的对象
7. 如果非成员函数是类接口的组成部分，则这些函数的声明应该与类在同一个头文件内
8. **构造函数**来控制其对象的初始化过程，无论何时只要类的对象被创建，就会执行构造函数
9. **默认构造函数**按照如下规则初始化类的数据成员

* 如果存在类内的初始值，用它来初始化成员
* 否则，默认初始化该成员

10. **只有当类没有声明任何构造函数时，编译器才会自动地生成默认构造函数**
11. **如果类包含有内置类型或者复合类型的成员，则只有当这些成员全都被赋予了类内的初始值时，这个类才适合于使用合成的默认构造函数**
12. 如果我们需要默认行为，可以通过在参数列表后面写上`=default`来要求编译器生成构造函数
13. 构造函数不应该轻易覆盖掉类内的初始值，除非新赋的值与原值不同。如果你不能使用类内初始化，则所有构造函数都应该显示地初始化每个内置类型的成员
14. **要控制类的对象初始化过程、拷贝、赋值以及销毁对象时发生的行为**
15. 定义在`public`说明符之后的成员在整个程序内可被访问，`public`成员定义类的接口；定义在`private`说明符之后的成员可以被类的成员函数访问，但是不能被使用该类的代码访问，`private`部分封装了(即隐藏了)类的实现细节
16. `class`和`struct`不同点是默认的访问权限，`class`默认的是`private`，`struct`默认的是`public`
17. **友元**可以允许其他类或者函数访问它的非公有成员，方法是令其他类或者函数成员它的**友元**
18. 一般来说，最好在类定义开始或结束前的位置集中声明友元
19. 可以通过`typedef`在类中定义类型，但是用来定义类型的成员必须先定义后使用

```c++
class Screen{
public:
    typedef std::string::size_type pos;
private:
    pos cursor = 0;
    pos height = 0, width = 0;
    std::string contents;
};
```

20. 和在头文件定义`inline`函数的原因一样，`inline`成员函数也应该与相应的类定义在同一个头文件中
21. `mutable`定义可变数据成员，如果该成员是个可变成员，因此任何成员函数，包括`const`函数在内都能改变它的值
22. 当提供一个类内初始值时，必须以符号`=`或者花括号表示
23. 一个`const`成员函数如果以引用的形式返回`*this`，那么它的返回类型将是常量引用

24. 即使两个类的成员列表完全一致，它们也是不同的类型
25. 类的**前向声明**向程序中引入类名字并指定其是一个类类型
26. 每个类负责控制自己的友元类或友元函数

27. 通过`::`可以在类中访问全局的跟类中相同的变量名
28. 如果成员是`const`、引用，或者属于某种未提供默认构造函数的类类型，必须通过构造函数初始值列表为这些成员提供初值
29. 在很多类中，初始化和赋值的区别事关底层效率问题：前者直接初始化数据成员，后者则先初始化再赋值

30. 构造函数初始值的顺序与成员声明的顺序保持一致。而且如果可能的话，尽量避免使用某些成员初始化其他成员
31. 委托构造函数可以使用它所属类的其他构造函数执行它自己的初始化过程

```c++
class Sales_data{
public:
    Sales_data(std::string s, unsigned cnt, double price):bookNo(s), units_sold(cnt), revenue(cnt*price){}
    Sales_data():Sales_data("", 0, 0){}
    Sales_data(std::string s):Sales_data(s, 0, 0){}
    Sales_data(std::istream &is):Sales_data(){read(is, *this);}
};
```

32. 当对象被默认初始化或值初始化时自动执行默认构造函数。默认初始化在以下情况下发生：

* 当在块作用域内不使用任何初始值定义一个非静态变量或数组时
* 当一个类本身含有类类型的成员且使用合成的默认构造函数时
* 当类类型的成员没有在构造函数初始值列表中显式地初始化时

值初始化再以下情况下发生：

* 在数组初始化的过程中如果我们提供的初始化值数量小于数组的大小时
* 当我们不使用初始值定义一个局部静态变量时
* 当我们通过书写形如T()的表达式显示地请求值初始化时，其中T是类型名，它就是使用一种这种形式的实参来对它的元素初始化器进行值初始化

33. 通过`explicit`来抑制构造函数定义的隐式转换，关键字`explicit`只对一个实参的构造函数有效
34. `explicit`构造函数只能用于直接初始化
35. 类的静态成员存在于任何对象之外，对象中不包含任何与静态数据成员相关的数据。它被所有对象共享，类似地，静态成员函数也不与任何对象绑定在一起，不包含`this`指针，所有静态成员函数不能声明为`const`，而且也不能在`static`函数体内使用`this`指针

