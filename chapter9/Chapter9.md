# Chapter9

1. 顺序容器

| 容器           | 备注                                                         |
| -------------- | ------------------------------------------------------------ |
| `vector`       | 可变大小数组。支持快速随机访问。在尾部之外的位置插入或删除元素可能很慢 |
| `deque`        | 双端队列。支持快速随机访问。在头尾位置插入/删除速度很快      |
| `list`         | 双向链表。只支持双向顺序访问。在`list`中任何位置进行插入/删除操作速度都很快 |
| `forward_list` | 单向链表。只支持单向顺序访问。在链表任何位置进行插入/删除操作速度都很快 |
| `array`        | 固定大小数组。支持快速随机访问。不能添加或删除元素           |
| `string`       | 与`vector`相似的容器，但专门用于保存字符。随机访问快。在尾部插入/删除速度快 |

2. 容器选择

* 除非有很好的理由选择其他容器，否则应使用`vector`
* 如果程序有很多小元素，且空间的额外开销很重要，则不要使用`list`或`forward_list`
* 如果程序要求随机访问元素，应使用`vector`或`deque`
* 如果程序要求在容器的中间插入或删除元素，应使用`list`或`forward_list`
* 如果程序需要在头尾位置插入或删除元素，但不会在中间位置进行插入或删除操作，则使用`deque`
* 如果程序只有在读取输入时才需要在容器中间位置插入元素，随后需要随机访问元素，则(1)首先确定是否真的需要在容器中间位置添加元素。当处理输入数据时，通常可以很容易地向`vector`追加数据，然后再调用标准库的`sort`函数来重排容器中的元素，从而避免在中间位置添加元素(2)如果必须在中间位置插入元素，考虑在输入阶段使用`list`，一旦输入完成，将`list`中的内容拷贝到一个`vector`中

3. 不同容器定义在同名的容器库当中，例如`vector`定义在`<vector>`头文件中

4. 容器通用操作

| 通用操作                               | 备注                                                      |
| -------------------------------------- | --------------------------------------------------------- |
| 类型别名                               |                                                           |
| iterator                               | 此容器类型的迭代器类型                                    |
| const_iterator                         | 可以读取元素，但不能修改元素的迭代器类型                  |
| size_type                              | 无符号整数类型，足够保存此种容器类型最大可能容器的大小    |
| difference_type                        | 带符号整数类型，足够保存两个迭代器之间的距离              |
| value_type                             | 元素类型                                                  |
| reference                              | 元素的左值类型；与value_type&含义相同                     |
| const_reference                        | 元素的const左值类型(即const value_type&)                  |
| 构造函数                               |                                                           |
| C c;                                   | 默认构造函数，构造空容器                                  |
| C c1(c2);                              | 构造c2的拷贝c1                                            |
| C c(b, e);                             | 构造c，将迭代器b和e指定的范围内的元素拷贝到c(array不支持) |
| C c(a, b, c...);                       | 列表初始化c                                               |
| 赋值与swap                             |                                                           |
| c1 = c2                                | 将c1的元素替换为c2中元素                                  |
| c1 = {a, b, c...}                      | 将c1中的元素替换为列表中元素(不适用于array)               |
| a.swap(b)                              | 交换a和b的元素                                            |
| swap(a, b)                             | 与a.swap(b)等价                                           |
| 大小                                   |                                                           |
| c.size()                               | c中元素的数目(不支持forward_list)                         |
| c.max_size()                           | c可保存的最大元素数目                                     |
| c.empty()                              | 若c中存储了元素，返回false，否则返回true                  |
| 添加/删除元素(不适用于array)           | 在不同的容器中，这些操作的接口都不同                      |
| c.insert(args)                         | 将args中的元素拷贝进c                                     |
| c.emplace(inits)                       | 使用inits构造c中的一个元素                                |
| c.erase(args)                          | 删除args指定的元素                                        |
| c.clear()                              | 删除c中的所有元素，返回void                               |
| 关系运算符                             |                                                           |
| ==, !=                                 | 所有容器都支持相等(不等)运算符                            |
| <, <=, >, >=                           | 关系运算符(无序关联容器不支持)                            |
| 获取迭代器                             |                                                           |
| c.begin(), c.end()                     | 返回指向c的首元素和尾元素之后位置的迭代器                 |
| c.cbegin(), c.cend()                   | 返回const_interator                                       |
| 反向容器的额外成员(不支持forward_list) |                                                           |
| reverse_iterator                       | 按逆序寻址元素的迭代器                                    |
| const_reverse_iterator                 | 不能修改元素的逆序迭代器                                  |
| c.rbegin(), c.rend()                   | 返回指向c的尾元素和首元素之前位置的迭代器                 |
| c.crbegin(), c.crend()                 | 返回const_reverse_interator                               |

5. `forward_list`迭代器不支持递减运算符
6. 当不需要写访问时，应使用`cbegin`和`cend`

7. 容器定义和初始化

| 定义和初始化      | 备注                                                         |
| ----------------- | ------------------------------------------------------------ |
| `C c;`            | 默认构造函数。如果`C`是一个`array`。则`c`中元素按默认方式初始化；否则`c`为空 |
| `C c1(c2)`        | `c1`初始化为`c2`的拷贝。`c1`和`c2`必须是相同类型(即，它们必须是相同的容器类型，且保存的是相同的元素类型；对于`array`类型，两者还必须具有相同大小) |
| `C c(a, b, c...)` | `c`初始化为初始化列表中元素的拷贝。列表中元素的类型必须与`C`的元素类型相同。对于`array`类型，列表中元素数目必须等于或小于`array`的大小，任何遗漏的元素都进行初始化 |
| `C c(b, e)`       | `c`初始化为迭代器`b`和`e`指定范围中的元素的拷贝。范围中元素的类型必须与`C`的元素类型相容(`array`不适用) |
|                   | 只有顺序容器(不包括`array`)的构造函数才能接受大小参数        |
| `C seq(n)`        | seq包含n个元素，这些元素进行了值初始化；此构造函数是explicit的(string不适用) |
| `C seq(n, t)`     | seq包含n个初始化为值t的元素                                  |

8. 当将一个容器**初始化**为另一个容器的**拷贝**时，两个容器的容器类型和元素类型都必须相同
9. 使用迭代器参数进行拷贝时，就不要求容器类型是相同的，其次新容器和原容器中的元素类型也可以不同，只要能将要拷贝的元素转换为要初始化的容器的元素类型即可
10. 只有顺序容器的构造函数才接受大小参数，关联容器并不支持
11. 标准库`array`具有固定大小

```c++
array<int, 42>
array<string, 10>
```

12. 内置数组类型不支持拷贝或对象赋值，但是`array`支持，它要求初始值的类型必须与要创建的容器类型相同，此外，`array`还要求元素类型和大小都一样，因为大小是`array`类型的一部分

13. 容器赋值运算

| 操作                          | 备注                                                         |
| ----------------------------- | ------------------------------------------------------------ |
| c1=c2                         | 将c1中的元素替换为c2中元素的拷贝。c1和c2必须具有相同的类型   |
| c={a, b, c...}                | 将c1中元素替换为初始化列表中元素的拷贝(array不适用)          |
| swap(c1, c2)<br />c1.swap(c2) | 交换c1和c2中的元素。c1和c2必须具有相同的类型。swap通常比从c2向c1拷贝元素快得多 |
|                               | assign操作不适用于关联容器和array                            |
| seq.assign(b, e)              | 将seq中的元素替换为迭代器b和e所表示的范围中的元素。迭代器b和e不能指向seq中的元素 |
| seq.assign(il)                | 将seq中的元素替换为初始化列表il中的元素                      |
| seq.assign(n, t)              | 将seq中的元素替换为n个值为t的元素                            |

14. 赋值相关运算会导致指向左边容器内部的迭代器、引用和指针失效。而`swap`操作将容器内容交换不会导致指向容器的迭代器、引用和指针失效(容器类型array和string的情况除外)

15. 除`array`外，`swap`不对任何元素进行拷贝、删除或插入操作，因此可以保证在常熟时间内完成

16. `swap`两个`array`会真正交换它们的元素。因此，交换两个`array`所需的时间 与`array`中元素的数据成正比
17. 添加元素

| 操作                                      | 备注                                                         |
| ----------------------------------------- | ------------------------------------------------------------ |
|                                           | 这些操作会改变容器的大小；array不支持这些操作                |
|                                           | forward_list有自己专有版本的insert和emplace                  |
|                                           | forward_list不支持push_back和emplace_back                    |
|                                           | vector和string不支持push_front和emplace_front                |
| c.push_back(t)<br />c.emplace_back(args)  | 在c的尾部创建一个值为t或由args创建的元素。返回void           |
| c.push_front()<br />c.emplace_front(args) | 在c的头部创建一个值为t或由args创建的元素。返回void           |
| c.insert(p, t)<br />c.emplace(p, args)    | 在迭代器p指向的元素之前创建一个值为t或由args创建的元素。返回指向新添加的元素的迭代器 |
| c.insert(p, n, t)                         | 在迭代器p指向的元素之前插入n个值为t的元素。返回指向新添加的第一个元素的迭代器；若n为0，则返回p |
| c.insert(p, b, e)                         | 将迭代器b和e指定的范围内的元素插入到迭代器p指向的元素之前。b和e不能指向c中的元素。返回指向新添加的第一个元素的迭代器；若范围为空，则返回p |
| c.insert(p, il)                           | il是一个花括号包围的元素值列表。将这些给定值插入到迭代器p指向的元素之前。返回指向新添加的第一个元素的迭代器。若列表为空，则返回p |

18. 向一个`vector`、`string`或`deque`插入元素会使所有指向容器的迭代器、引用和指针失效
19. 当我们用一个对象来初始化容器时，或将一个对象插入到容器中时，实际上放入到容器中的是对象值的一个拷贝，而不是对象本身。容器中的元素与提供值的对象之间没有任何关联

20. 将元素插入到`vector`、`deque`和`string`中的任何位置都是合法的。然而，这样做可能很耗时
21. 使用`insert`的返回值在容器中一个特定位置反复插入元素
22. 使用`emplace`操作构造而不是拷贝元素。`push`或`insert`成员函数是将元素类型的对象传递给它们，这些对象被拷贝到容器中，而使用`emplace`成员函数时，则是将参数传递给元素类型的构造函数，使用这些参数在容器管理的内存空间中直接构造元素

```c++
c.emplace_back("978-0590353403", 25, 15.99);
等价于
c.push_back(Sales_data("978-0590353403", 25, 15,99));
```

22. `front`返回首元素的引用；`back`返回尾元素的引用
23. 访问元素操作

| 操作      | 备注                                                         |
| --------- | ------------------------------------------------------------ |
|           | at和下标操作只适用于string、vector、deque和array；back不适用于forward_list |
| c.back()  | 返回c中尾元素的引用。若c为空，函数行为未定义                 |
| c.front() | 返回c中首元素的引用。若c为空，函数行为未定义                 |
| c[n]      | 返回c中下标为n的元素的引用，n是一个无符号整数。若n>=c.size(),则函数行为未定义 |
| c.at(n)   | 返回下边为n的元素的引用。如果下标越界，则抛出out_of_range异常 |

24. 删除元素操作

| 操作          | 备注                                                         |
| ------------- | ------------------------------------------------------------ |
|               | 这些操作会改变容器的大小，所以不适用于array<br />forward_list有特殊版本的erase<br />forward_list不支持pop_back;vector和string不支持pop_front |
| c.pop_back()  | 删除c中尾元素。若c为空，则函数行为未定义。函数返回void       |
| c.pop_front() | 删除c中首元素。若c为空，则函数行为未定义。函数返回void       |
| c.erase(p)    | 删除迭代器p所指定的元素，返回一个指向被删元素之后元素的迭代器，若p指向尾元素，则返回尾后(off-the-end)迭代器。若p是尾后迭代器，则函数行为未定义 |
| c.erase(b, e) | 删除迭代器b和e所指定范围内的元素。返回一个指向最后一个被删元素之后元素的迭代器，若e本身就是尾后迭代器，则函数也返回尾后迭代器 |
| c.clear()     | 删除c中的所有元素。返回void                                  |

25. 删除`deque`中除首尾位置之外的任何元素都会使所有迭代器、引用和指针失效。指向`vector`或`string`中删除点之后位置的迭代器、引用和指针都会失效
26. 删除元素的成员函数并不会检查其参数。在删除元素之前，程序员必须确保它们是存在的
27. `forward_list`插入以及删除元素操作

| 操作                                                         | 备注                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| lst.before_begin()<br />lst.cbefore_begin()                  | 返回指向链表首元素之前不存在的元素的迭代器。此迭代器不能解引用。cbefore_begin()返回一个const_iterator |
| lst.insert_after(p, t)<br />lst.insert_after(p, n, t)<br />lst.insert_after(p, b, e)<br />lst.insert_after(p, il) | 在迭代器p之后的位置插入元素。t是一个对象，n是数量，b和e是表示范围的一对迭代器(b和e不能指向1st内)，il是一个花括号列表。返回一个指向最后一个插入元素的迭代器。如果范围为空，则返回p。若p为尾后迭代器，则函数行为未定义 |
| emplace_after(p, args)                                       | 使用args在p指定的位置之后创建一个元素。返回一个指向这个新元素的迭代器。若p为尾后迭代器，则函数行为未定义 |
| lst.erase_after(p)<br />lst.erase_after(b, e)                | 删除p指向的位置之后的元素，或删除从b之后直到(但不包含)e之间的元素。返回一个指向被删元素之后元素的迭代器。若不存在这样的元素，则返回尾后迭代器。如果p指向lst的尾元素或者是一个尾后迭代器，则函数行为未定义 |

28. 改变容器大小

| 操作           | 备注                                                         |
| -------------- | ------------------------------------------------------------ |
|                | resize不适用于array                                          |
| c.resize(n)    | 调整c的大小为n个元素。若n<c.size()，则多出的元素被丢弃。若必须添加新元素，对新元素进行值初始化 |
| c.resize(n, t) | 调整c的大小为n个元素，任何新添加的元素都初始化为值t          |

29. 如果`resize`缩小容器，则指向被删除元素的迭代器、引用和指针都会失效；对`vector`、`string`或`deque`进行`resize`可能导致迭代器、指针和引用失效
30. 容器操作可能使迭代器失效

向容器添加元素后：

* 如果容器是`vector`或`string`，且存储空间被重新分配，则指向容器的迭代器、指针和引用都会失效。如果存储空间未重新分配，指向插入位置之前的元素的迭代器、指针和引用仍有效，但指向插入位置之后元素的迭代器、指针和引用将会失效
* 对于`deque`，插入到除首尾位置之外的任何位置都会导致迭代器、指针和引用失效。如果在首尾位置添加元素，迭代器会失效，但指向存在的元素的引用和指针不会失效
* 对于`list`和`forward_list`，指向容器的迭代器(包括尾后迭代器和首前迭代器)、指针和引用仍有效

从容器删除元素后：

* 对于`list`和`forward_list`，指向容器其他位置的迭代器(包括尾后迭代器和首前迭代器)、引用和指针仍有效
* 对于`deque`，如果在首尾之外的任何位置删除元素，那么指向被删除元素外其他元素的迭代器、引用或指针也会失效。如果是删除`deque`的尾元素，则尾后迭代器也会失效，但其他迭代器、引用和指针不受影响；如果是删除首元素，这些也不会受影响
* 对于`vector`和`string`，指向被删元素之前元素的迭代器、引用和指针仍有效。
* 删除元素时，尾后迭代器总是会失效

31. 如果在一个循环中插入/删除`deque`、`string`或`vector`中的元素，不要缓存`end`返回的迭代器

32. 容器大小管理

| 操作              | 备注                                                         |
| ----------------- | ------------------------------------------------------------ |
|                   | `shrink_to_fit`只适用于vector、string和deque<br />`capacity`和`reserve`只适用于vector和string |
| c.shrink_to_fit() | 请将capacity()减少为与size()相同大小                         |
| c.capacity()      | 不重新分配内存空间的话，c可以保存多少元素                    |
| c.reserve()       | 分配至少能容纳n个元素的内存空间                              |

33. 构造`string`的其他方法

| 操作                     | 备注                                                         |
| ------------------------ | ------------------------------------------------------------ |
|                          | n、len2和pos2都是无符号数                                    |
| string s(cp, n)          | s是cp指向的数组中前n个字符的拷贝，此数组至少应该包含n个字符  |
| string s(s2, pos2)       | s是string s2从下标pos2开始的字符的拷贝。若pos2>s2.size()，构造函数的行为未定义 |
| string s(s2, pos2, len2) | s是string s2从下标pos2开始len2个字符的拷贝。若pos2>s2.size()，构造函数的行为未定义。不管len2的值是多少，构造函数至多拷贝s2.size()-pos2个字符 |

34. 子字符串操作

| 操作             | 备注                                                         |
| ---------------- | ------------------------------------------------------------ |
| s.substr(pos, n) | 返回一个string，包含s中从pos开始的n个字符的拷贝。pos的默认值为0。n的默认值为s.size()-pos，即拷贝从pos开始的所有字符 |

35. 修改`string`操作

| 操作                   | 备注                                                         |
| ---------------------- | ------------------------------------------------------------ |
| s.insert(pos, args)    | 在pos之前插入args指定的字符。pos可以是一个下标或一个迭代器。接受下标的版本返回一个指向s的引用；接受迭代器的版本返回指向第一个插入字符的迭代器 |
| s.erase(pos, len)      | 删除从位置pos开始的len个字符。如果len被忽略，则删除从pos开始直至s末尾的所有字符。返回一个指向s的引用 |
| s.assign(args)         | 将s中的字符替换为args指定的字符。返回一个指向s的引用         |
| s.append(args)         | 将args追加到s。返回一个指向s的引用                           |
| s.replace(range, args) | 删除s中范围range内的字符，替换为args指定的字符。range或者是一个下标和一个长度，或者是一对指向s的迭代器。返回一个指向s的引用 |
|                        | args可以是下列形式之一：append和assign可以使用所有形式<br />str不能与s相同，迭代器b和e不能指向s |
| str                    | 字符串str                                                    |
| str, pos, len          | str中从pos开始最多len个字                                    |
| cp, len                | 从cp指向的字符数组的前(最多)len个字符                        |
| cp                     | cp指向的以空字符结尾的字符数组                               |
| n, c                   | n个字符c                                                     |
| b, e                   | 迭代器b和e指定的范围内的字符                                 |
| 初始化列表             | 花括号包围的，以逗号分隔的字符列表                           |

35. `string`搜索操作

| 操作                      | 备注                                                         |
| ------------------------- | ------------------------------------------------------------ |
|                           | 搜索操作返回指定字符出现的下标，如果未找到则返回npos         |
| s.find(args)              | 查找s中args第一次出现的位置                                  |
| s.rfind(args)             | 查找s中args最后一次出现的位置                                |
| s.find_first_of(args)     | 在s中查找args中任何一个字符第一次出现的位置                  |
| s.find_last_of(args)      | 在s中查找args中任何一个字符最后一次出现的位置                |
| s.find_first_not_of(args) | 在s中查找第一个不在args中的字符                              |
| s.find_last_not_of(args)  | 在s中查找最后一个不在args中的字符                            |
|                           | args必须是以下形式之一                                       |
| c, pos                    | 从s中位置pos开始查找字符c。pos默认为0                        |
| s2, pos                   | 从s中位置pos开始查找字符串s2。pos默认为0                     |
| cp, pos                   | 从s中位置pos开始查找指针cp指向的以空字符结尾的c风格字符串。pos默认为0 |
| cp, pos, n                | 从s中位置pos开始查找指针cp指向的数组的前n个字符。pos和n无默认值 |

36. `s.compare`函数

| 参数形式               | 备注                                                         |
| ---------------------- | ------------------------------------------------------------ |
| s2                     | 比较s和s2                                                    |
| pos1, n1, s2           | 将s中从pos1开始的n1个字符与s2进行比较                        |
| pos1, n1, s2, pos2, n2 | 将s中从pos1开始的n1个字符与s2中从pos2开始的n2个字符进行比较  |
| cp                     | 比较s与cp指向的以空字符结尾的字符数组                        |
| pos1, n1, cp           | 将s中从pos1开始的n1个字符与cp指向的以空字符结尾的字符数组进行比较 |
| pos1, n1, cp, n2       | 将s中从pos1开始的n1个字符与指针cp指向的地址开始的n2个字符进行比较 |

37. `string`和数值之间的转换

| 操作                                                         | 备注                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| to_string(val)                                               | 一组重载函数，返回数值val的string表示。val可以是任何算数类型。对每个浮点类型和int或更大的整型，都有相应版本的to_string。与往常一样，小整型会被提升 |
| stoi(s, p, b)<br />stol(s, p, b)<br />stoul(s, p, b)<br />stoll(s, p, b)<br />stoull(s, p, b) | 返回s的起始子串(表示整数内容)的数值，返回值类型分别是int、long、unsigned long、long long、unsigned long long。b表示转换所用的基数，默认值是10。p是size_t指针，用来保存s中第一个非数值字符的下标，p默认为0，即，函数不保存下标 |
| stof(s, p)<br />stod(s, p)<br />stold(s, p)                  | 返回s的起始子串(表示浮点数内容)的数值，返回值类型分别是float、double或long double。参数p的作用与整数转换函数中一样 |

38. 容器适配器`stack`、`queue`和`priority_queue`

| 操作及类型                | 备注                                                         |
| ------------------------- | ------------------------------------------------------------ |
| size_type                 | 一种类型，足以保存当前类型的最大对象的大小                   |
| value_type                | 元素类型                                                     |
| container_type            | 实现适配器的底层容器类型                                     |
| A a;                      | 创建一个名为a的空适配器                                      |
| A a(c);                   | 创建一个名为a的适配器，带有容器c的一个拷贝                   |
| 关系运算符                | 每个适配器都支持所有关系运算符：==、!=、<、<=、>和>= 这些运算符返回底层容器的比较结果 |
| a.empty()                 | 若a包含任何元素，返回false，否则返回true                     |
| a.size()                  | 返回a中的元素数目                                            |
| swap(a, b)<br />a.swap(b) | 交换a和b的内容，a和b必须有相同类型，包括底层容器类型也必须相同 |

39. 所有适配器都要求容器具有添加和删除元素的能力
40. 栈操作

| 操作                              | 备注                                                         |
| --------------------------------- | ------------------------------------------------------------ |
|                                   | 栈默认基于deque实现，也可以在list或vector之上实现            |
| s.pop()                           | 删除栈顶元素，但不返回该元素值                               |
| s.push(item)<br />s.emplace(args) | 创建一个新元素压入栈顶，该元素通过拷贝或移动item而来，或者由args构造 |
| s.top()                           | 返回栈顶元素，但不将元素弹出栈                               |

41. 队列操作

| 操作            | 备注                                                         |
| --------------- | ------------------------------------------------------------ |
|                 | queue默认基于deque实现，priority_queue默认基于vector实现<br />queue也可以用list或vector实现，priority_queue也可以用deque实现 |
| q.pop()         | 返回queue的首元素或priority_queue的最高优先级的元素，但不删除此元素 |
| q.front()       | 返回首元素或尾元素，但不删除此元素                           |
| q.back()        | 只适用于queue                                                |
| q.top()         | 返回最高优先级元素，但不删除该元素                           |
| q.push(item)    | 在queue末尾或priority_queue中恰当的位置创建一个元素          |
| q.emplace(args) | 其值为item，或者由args构造                                   |

